<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema ML de Wildflowers - Base de Datos √önica</title>

    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/i18next-browser-languagedetector@7.2.0/i18nextBrowserLanguageDetector.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            max-width: 400px;
            z-index: 1000;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .controls button {
            margin: 5px;
            padding: 8px 12px;
            cursor: pointer;
            display: block;
            width: 200px;
        }
        
        .form-group {
            margin-bottom: 10px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .coordinates-input {
            display: flex;
            gap: 10px;
        }
        
        .coordinates-input input {
            flex: 1;
        }
        
        .user-point-marker {
            background-color: #ff00ff !important;
        }
        
        .ml-vertex-marker {
            background-color: #00ff00 !important;
        }
        
        .tab-container {
            margin-top: 15px;
        }
        
        .tab-buttons {
            display: flex;
            margin-bottom: 10px;
        }
        
        .tab-button {
            flex: 1;
            padding: 8px;
            background: #f0f0f0;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }
        
        .tab-button.active {
            background: #3388ff;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .status-indicator {
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }
        
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .ml-explanation {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .ml-explanation h5 {
            margin-top: 0;
            color: #333;
        }
        
        .ml-explanation ul {
            padding-left: 15px;
        }
        
        .ml-explanation li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div id="info-panel">
        <h3>üå∫ Sistema ML Wildflowers</h3>
        <div class="status-indicator status-info">
            Base de Datos √önica: Combinada
        </div>
        
        <div class="tab-container">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="showTab('info-tab')">Info</button>
                <button class="tab-button" onclick="showTab('add-tab')">A√±adir</button>
                <button class="tab-button" onclick="showTab('data-tab')">Datos</button>
                <button class="tab-button" onclick="showTab('ml-tab')">ü§ñ ML Info</button>
            </div>
            
            <div id="info-tab" class="tab-content active">
                <div id="site-info">
                    <p>Selecciona un √°rea para ver detalles</p>
                </div>
                
                <div id="legend">
                    <h4>Leyenda</h4>
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <div style="width: 20px; height: 20px; background-color: #ff00ff; margin-right: 10px; opacity: 0.7;"></div>
                        <span>√Åreas de Inter√©s con posibles florecimientos</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <div style="width: 12px; height: 12px; background-color: #ff00ff; border-radius: 50%; margin-right: 10px;"></div>
                        <span>Puntos de Usuario</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <div style="width: 12px; height: 12px; background-color: #00ff00; border-radius: 50%; margin-right: 10px;"></div>
                        <span>V√©rtices ML</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <div style="width: 25px; height: 5px; background: linear-gradient(90deg, red,  yellow,  lime, cyan, blue); margin-right: 10px;"></div>
                        <span>Posibles puntos de floraci√≥n</span>
                    </div>
                </div>
                
                <div id="auto-generation-status" class="status-indicator status-success" style="margin-top: 15px;">
                    ‚úÖ Pol√≠gonos ML generados autom√°ticamente
                </div>
            </div>
            
            <div id="add-tab" class="tab-content">
                <h4>‚ûï A√±adir Punto</h4>
                <div class="form-group">
                    <label for="site-name">Nombre:</label>
                    <input type="text" id="site-name" placeholder="Ej: Mi Nuevo Sitio">
                </div>
                
                <div class="form-group">
                    <label for="site-type">Tipo:</label>
                    <select id="site-type">
                        <option value="Wild">Wild</option>
                        <option value="Plantation">Plantation</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="site-season">Temporada:</label>
                    <input type="text" id="site-season" placeholder="Ej: Spring, Summer">
                </div>
                
                <div class="form-group">
                    <label for="site-area">√Årea (m¬≤):</label>
                    <input type="number" id="site-area" placeholder="Ej: 5000" min="0" step="0.001">
                </div>
                
                <div class="form-group">
                    <label>Coordenadas:</label>
                    <div class="coordinates-input">
                        <input type="text" id="site-lat" placeholder="Latitud" pattern="-?\d+(\.\d+)?">
                        <input type="text" id="site-lng" placeholder="Longitud" pattern="-?\d+(\.\d+)?">
                    </div>
                </div>
                
                <div class="form-group">
                    <button onclick="addUserPoint()" style="background-color: #4CAF50; color: white; border: none; padding: 10px; border-radius: 4px; width: 100%;">A√±adir Punto</button>
                    <button onclick="toggleGetCoordsMode()" id="get-coords-btn" style="background-color: #2196F3; color: white; border: none; padding: 10px; border-radius: 4px; width: 100%; margin-top: 5px;">Obtener Coordenadas del Clic</button>
                </div>
            </div>
            
            <div id="data-tab" class="tab-content">
                <h4>üìä Gesti√≥n de Datos</h4>
                <p><strong>Puntos de usuario:</strong> <span id="user-points-count">0</span></p>
                <p><strong>Pol√≠gonos ML:</strong> <span id="ml-polygons-count">0</span></p>
                <p><strong>V√©rtices ML:</strong> <span id="ml-vertices-count">0</span></p>
                <p><strong>Pol√≠gonos totales:</strong> <span id="total-polygons-count">0</span></p>
                
                <button onclick="generateMLPolygons()" style="background-color: #9C27B0; color: white; border: none; padding: 10px; border-radius: 4px; width: 100%; margin-top: 10px;">üîÑ Generar Pol√≠gonos ML</button>
                <button onclick="exportData()" style="background-color: #FF9800; color: white; border: none; padding: 10px; border-radius: 4px; width: 100%; margin-top: 5px;">üì§ Exportar Base de Datos</button>
                <button onclick="clearUserPoints()" style="background-color: #f44336; color: white; border: none; padding: 10px; border-radius: 4px; width: 100%; margin-top: 5px;">üóëÔ∏è Limpiar Mis Puntos</button>
                <button onclick="resetDatabase()" style="background-color: #607d8b; color: white; border: none; padding: 10px; border-radius: 4px; width: 100%; margin-top: 5px;">üîÑ Resetear Base de Datos</button>
            </div>
            
            <div id="ml-tab" class="tab-content">
                <h4>ü§ñ Explicaci√≥n del Machine Learning</h4>
                <div id="ml-explanation-content">
                    <p>Cargando informaci√≥n del ML...</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="toggle-heatmap" onclick="toggleHeatmap()">Ocultar Heatmap</button>
        <button id="toggle-ml" onclick="toggleMLPolygons()">Ocultar √Årea de inter√©s</button>
        <button id="toggle-users-vertices" onclick="toggleAllPoints()">Ocultar Usuarios y V√©rtices</button>
        <button onclick="resetView()">Vista Inicial</button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Heat Plugin -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    
    <script>
        // Variables globales
        let map;
        let heatLayer;
        let originalLayer;
        let mlLayer;
        let userPointsLayer;
        let mlVerticesLayer;
        let isGettingCoords = false;
        let userPoints = [];
        let mlVertices = [];
        let originalPointsLayer;
        let originalPoints = [];

        // Inicializar mapa
        function initMap() {
            map = L.map('map').setView([36.7783, -119.4179], 6);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            userPointsLayer = L.layerGroup().addTo(map);
            mlVerticesLayer = L.layerGroup().addTo(map);
            originalPointsLayer = L.layerGroup().addTo(map); // ‚úÖ NUEVA CAPA
            
            loadAllData();
        }
        async function loadOriginalPoints() {
            try {
                const response = await fetch('/api/original-points');
                originalPoints = await response.json();
                
                originalPointsLayer.clearLayers();
                
                originalPoints.forEach(point => {
                    const marker = L.marker([point.lat, point.lng], {
                        icon: L.divIcon({
                            className: 'original-point-marker',
                            html: '<div style="background-color: #3388ff; width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>',
                            iconSize: [14, 14]
                        })
                    }).addTo(originalPointsLayer);
                    
                    marker.bindPopup(`
                        <div class="original-point-popup">
                            <h4>üèûÔ∏è ${point.site_name || 'Punto Original'}</h4>
                            <p><strong>Tipo:</strong> ${point.type || 'Original'}</p>
                            <p><strong>Temporada:</strong> ${point.season || 'No especificada'}</p>
                            <p><strong>√Årea:</strong> ${point.area || 0} m¬≤</p>
                            <p><strong>Coordenadas:</strong> ${point.lat?.toFixed(4)}, ${point.lng?.toFixed(4)}</p>
                            <p><em>Datos originales del GeoJSON</em></p>
                        </div>
                    `);
                });
                
                console.log(`‚úÖ ${originalPoints.length} puntos originales cargados como marcadores visibles`);
                
            } catch (error) {
                console.error('Error cargando puntos originales:', error);
            }
        }
        // Cargar todos los datos desde la BASE DE DATOS COMBINADA
        async function loadAllData() {
            await loadOriginalPolygons();
            await loadMLPolygons();
            await loadUserPoints();
            await loadMLVertices();
            await loadOriginalPoints(); // ‚úÖ CARGAR PUNTOS ORIGINALES
            await loadMLExplanation();
            updateHeatmap();
            updateCounts();
        }


        // Cargar pol√≠gonos originales desde la base de datos combinada
        async function loadOriginalPolygons() {
            try {
                const response = await fetch('/api/original-polygons');
                const data = await response.json();
                
                if (originalLayer) {
                    map.removeLayer(originalLayer);
                }
                
                originalLayer = L.geoJSON(data, {
                    style: function(feature) {
                        return {
                            color: '#3388ff',
                            weight: 2,
                            opacity: 0.7,
                            fillColor: getColorByType(feature.properties.Type),
                            fillOpacity: 0.2
                        };
                    },
                    onEachFeature: function(feature, layer) {
                        if (feature.properties) {
                            const popupContent = `
                                <div>
                                    <h3>${feature.properties.Site || 'Sin nombre'}</h3>
                                    <p><strong>Tipo:</strong> ${feature.properties.Type || 'No especificado'}</p>
                                    <p><strong>Temporada:</strong> ${feature.properties.Season || 'No especificada'}</p>
                                    <p><strong>√Årea:</strong> ${(feature.properties.Area || 0).toLocaleString()} m¬≤</p>
                                    <p><em>Datos originales</em></p>
                                </div>
                            `;
                            layer.bindPopup(popupContent);
                        }
                    }
                })
                
            } catch (error) {
                console.error('Error cargando pol√≠gonos originales:', error);
            }
        }

        // Cargar pol√≠gonos ML desde la base de datos combinada
        async function loadMLPolygons() {
            try {
                const response = await fetch('/api/ml-polygons');
                const data = await response.json();
                
                if (mlLayer) {
                    map.removeLayer(mlLayer);
                }
                
                mlLayer = L.geoJSON(data, {
                    style: {
                        color: '#ff00ff',
                        weight: 3,
                        opacity: 0.8,
                        fillColor: '#ff00ff',
                        fillOpacity: 0.2,
                        dashArray: '5, 5'
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties || {};
                        let popupContent = `
                            <div>
                                <h3>${props.Site || '√Årea ML'}</h3>
                                <p><strong>Tipo:</strong> ${props.Type || 'Auto-generado'}</p>
                                <p><strong>Temporada:</strong> ${props.Season || 'Variable'}</p>
                                <p><strong>√Årea:</strong> ${(props.Area || 0).toLocaleString()} m¬≤</p>
                                <p><strong>Generado autom√°ticamente</strong></p>
                                <p><strong>Puntos en cluster:</strong> ${props.point_count || 'N/A'}</p>
                                <p><strong>Puntos de usuario:</strong> ${props.user_points || 'N/A'}</p>
                        `;
                        
                        if (props.original_polygons_involved && props.original_polygons_involved.length > 0) {
                            popupContent += `<p><strong>Pol√≠gonos involucrados:</strong> ${props.original_polygons_involved.join(', ')}</p>`;
                        }
                        
                        popupContent += `</div>`;
                        layer.bindPopup(popupContent);
                    }
                }).addTo(map);
                
            } catch (error) {
                console.error('Error cargando pol√≠gonos ML:', error);
            }
        }

        // Cargar puntos de usuario
        async function loadUserPoints() {
            try {
                const response = await fetch('/api/user-points');
                userPoints = await response.json();
                
                userPointsLayer.clearLayers();
                
                userPoints.forEach(point => {
                    const marker = L.marker([point.lat, point.lng], {
                        icon: L.divIcon({
                            className: 'user-point-marker',
                            html: '<div style="background-color: #ff00ff; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>',
                            iconSize: [16, 16]
                        })
                    }).addTo(userPointsLayer);
                    
                    marker.bindPopup(`
                        <div class="user-point-popup">
                            <h4>üìç ${point.name || 'Punto de usuario'}</h4>
                            <p><strong>Tipo:</strong> ${point.type || 'No especificado'}</p>
                            <p><strong>Temporada:</strong> ${point.season || 'No especificada'}</p>
                            <p><strong>√Årea:</strong> ${point.area || 0} m¬≤</p>
                            <p><strong>Coordenadas:</strong> ${point.lat?.toFixed(4)}, ${point.lng?.toFixed(4)}</p>
                            <button onclick="removeUserPoint('${point.id}')" style="background-color: #ff4757; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Eliminar</button>
                        </div>
                    `);
                });
                
                console.log(`‚úÖ ${userPoints.length} puntos de usuario cargados como marcadores visibles`);
                
            } catch (error) {
                console.error('Error cargando puntos de usuario:', error);
            }
        }

        // Cargar v√©rtices ML como puntos visibles
        async function loadMLVertices() {
            try {
                const response = await fetch('/api/ml-vertices');
                mlVertices = await response.json();
                
                mlVerticesLayer.clearLayers();
                
                mlVertices.forEach(vertex => {
                    const marker = L.marker([vertex.lat, vertex.lng], {
                        icon: L.divIcon({
                            className: 'ml-vertex-marker',
                            html: '<div style="background-color: #00ff00; width: 8px; height: 8px; border-radius: 50%; border: 1px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.5);"></div>',
                            iconSize: [10, 10]
                        })
                    }).addTo(mlVerticesLayer);
                    
                    marker.bindPopup(`
                        <div>
                            <h4>V√©rtice ML</h4>
                            <p><strong>Pol√≠gono:</strong> ${vertex.source_polygon || 'N/A'}</p>
                            <p><strong>Tipo:</strong> ${vertex.type || 'V√©rtice'}</p>
                            <p><em>Generado autom√°ticamente</em></p>
                        </div>
                    `);
                });
                
            } catch (error) {
                console.error('Error cargando v√©rtices ML:', error);
            }
        }

        // Cargar explicaci√≥n del ML
        async function loadMLExplanation() {
            try {
                const response = await fetch('/api/ml-explanation');
                const explanation = await response.json();
                
                const content = document.getElementById('ml-explanation-content');
                content.innerHTML = `
                    <div class="ml-explanation">
                        <h5>üîç Algoritmo Utilizado: ${explanation.algorithm}</h5>
                        <p><strong>Prop√≥sito:</strong> ${explanation.purpose}</p>
                        
                        <h5>‚öôÔ∏è Par√°metros del DBSCAN:</h5>
                        <ul>
                            <li><strong>eps (Œµ):</strong> ${explanation.parameters.eps} - ${explanation.parameters.eps_meaning}</li>
                            <li><strong>min_samples:</strong> ${explanation.parameters.min_samples} - ${explanation.parameters.min_samples_meaning}</li>
                        </ul>
                        
                        <h5>üéØ Criterios de Decisi√≥n:</h5>
                        <ul>
                            <li><strong>Puntos Centrales (Core Points):</strong> ${explanation.decision_criteria.core_points}</li>
                            <li><strong>Puntos Frontera (Border Points):</strong> ${explanation.decision_criteria.border_points}</li>
                            <li><strong>Puntos de Ruido (Noise Points):</strong> ${explanation.decision_criteria.noise_points}</li>
                            <li><strong>Formaci√≥n de Clusters:</strong> ${explanation.decision_criteria.cluster_formation}</li>
                        </ul>
                        
                        <h5>üìê Formaci√≥n de Pol√≠gonos:</h5>
                        <ul>
                            <li><strong>Algoritmo:</strong> ${explanation.polygon_formation.algorithm}</li>
                            <li><strong>Prop√≥sito:</strong> ${explanation.polygon_formation.purpose}</li>
                            <li><strong>Resultado:</strong> ${explanation.polygon_formation.output}</li>
                        </ul>
                        
                        <h5>‚úÖ Ventajas:</h5>
                        <ul>
                            ${explanation.advantages.map(adv => `<li>${adv}</li>`).join('')}
                        </ul>
                        
                        <h5>‚ö†Ô∏è Limitaciones:</h5>
                        <ul>
                            ${explanation.limitations.map(lim => `<li>${lim}</li>`).join('')}
                        </ul>
                    </div>
                `;
                
            } catch (error) {
                console.error('Error cargando explicaci√≥n ML:', error);
                document.getElementById('ml-explanation-content').innerHTML = '<p>Error cargando informaci√≥n del ML</p>';
            }
        }

        // A√±adir punto de usuario
        async function addUserPoint() {
            const name = document.getElementById('site-name').value;
            const type = document.getElementById('site-type').value;
            const season = document.getElementById('site-season').value;
            const area = parseFloat(document.getElementById('site-area').value) || 1000;
            const lat = parseFloat(document.getElementById('site-lat').value);
            const lng = parseFloat(document.getElementById('site-lng').value);
            
            if (!name || isNaN(lat) || isNaN(lng)) {
                alert('Por favor, completa al menos el nombre y las coordenadas.');
                return;
            }
            
            try {
                const response = await fetch('/api/add-user-point', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: name,
                        type: type,
                        season: season,
                        area: area,
                        lat: lat,
                        lng: lng
                    })
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Limpiar formulario
                    document.getElementById('site-name').value = '';
                    document.getElementById('site-season').value = '';
                    document.getElementById('site-area').value = '';
                    document.getElementById('site-lat').value = '';
                    document.getElementById('site-lng').value = '';
                    
                    // Recargar puntos y actualizar heatmap
                    await loadUserPoints();
                    await loadMLVertices();
                    updateHeatmap();
                    updateCounts();
                    
                    alert('‚úÖ Punto a√±adido a la base de datos combinada.');
                } else {
                    alert('‚ùå Error a√±adiendo punto: ' + result.message);
                }
                
            } catch (error) {
                console.error('Error a√±adiendo punto:', error);
                alert('‚ùå Error a√±adiendo punto.');
            }
        }

        // Eliminar punto de usuario (funci√≥n placeholder)
        async function removeUserPoint(pointId) {
            if (confirm('¬øEst√°s seguro de que quieres eliminar este punto?')) {
                alert('Funcionalidad de eliminaci√≥n pendiente de implementar en el servidor');
            }
        }

        // Generar pol√≠gonos ML desde la base de datos combinada
        async function generateMLPolygons() {
            try {
                const response = await fetch('/api/generate-ml-polygons', {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Recargar TODOS los datos desde la base de datos combinada
                    await loadOriginalPolygons();
                    await loadMLPolygons();
                    await loadMLVertices();
                    updateHeatmap();
                    updateCounts();
                    alert('‚úÖ ' + result.message);
                } else {
                    alert('‚ùå ' + result.message);
                }
                
            } catch (error) {
                console.error('Error generando pol√≠gonos ML:', error);
                alert('‚ùå Error generando pol√≠gonos ML.');
            }
        }

        // Actualizar heatmap desde los CENTROIDES de pol√≠gonos ML
        async function updateHeatmap() {
            if (heatLayer) {
                map.removeLayer(heatLayer);
            }
            
            try {
                const response = await fetch('/api/heatmap-data');
                const data = await response.json();
                
                const heatPoints = data.heatmap_data.map(point => [
                    point.lat, point.lng, point.intensity
                ]);
                
                heatLayer = L.heatLayer(heatPoints, {
                    radius: 30,       // √°rea m√°s amplia ‚Üí menos concentraci√≥n visual
                    blur: 25,         // difumina m√°s
                    maxZoom: 10,
                    maxOpacity: 0.4,  // controla la intensidad global
                    gradient: {
                        0.0: 'blue',      // baja densidad
                        0.4: 'cyan',      // transicion suave
                        0.6: 'lime',      // densidad media
                        0.8: 'yellow',    // alta densidad
                        1.0: 'red'        // m√°xima densidad
                    }
                }).addTo(map);
                
            } catch (error) {
                console.error('Error actualizando heatmap:', error);
            }
        }

        // Funciones de control
        function toggleHeatmap() {
            const button = document.getElementById('toggle-heatmap');
            if (map.hasLayer(heatLayer)) {
                map.removeLayer(heatLayer);
                button.textContent = 'Mostrar Heatmap';
            } else {
                map.addLayer(heatLayer);
                button.textContent = 'Ocultar Heatmap';
            }
        }

        function toggleOriginalPolygons() {
            const button = document.getElementById('toggle-original');
            if (map.hasLayer(originalLayer)) {
                map.removeLayer(originalLayer);
                button.textContent = 'Mostrar Originales';
            } else {
                map.addLayer(originalLayer);
                button.textContent = 'Ocultar Originales';
            }
        }

        function toggleMLPolygons() {
            const button = document.getElementById('toggle-ml');
            if (map.hasLayer(mlLayer)) {
                map.removeLayer(mlLayer);
                button.textContent = 'Mostrar √Årea de Inter√©s';
            } else {
                map.addLayer(mlLayer);
                button.textContent = 'Ocultar √Årea de Inter√©s';
            }
        }

        function toggleAllPoints() {
            const button = document.getElementById('toggle-points');
            const allPointsVisible = map.hasLayer(userPointsLayer) && 
                                    map.hasLayer(mlVerticesLayer) && 
                                    map.hasLayer(originalPointsLayer);
            
            if (allPointsVisible) {
                map.removeLayer(userPointsLayer);
                map.removeLayer(mlVerticesLayer);
                map.removeLayer(originalPointsLayer);
                button.textContent = 'Mostrar Todos los Puntos';
            } else {
                map.addLayer(userPointsLayer);
                map.addLayer(mlVerticesLayer);
                map.addLayer(originalPointsLayer);
                button.textContent = 'Ocultar Todos los Puntos';
            }
        }

        function toggleGetCoordsMode() {
            isGettingCoords = !isGettingCoords;
            const button = document.getElementById('get-coords-btn');
            
            if (isGettingCoords) {
                button.textContent = 'Cancelar Obtenci√≥n';
                button.style.backgroundColor = '#ff6b6b';
                map.getContainer().style.cursor = 'crosshair';
                map.on('click', onMapClickGetCoords);
            } else {
                button.textContent = 'Obtener Coordenadas del Clic';
                button.style.backgroundColor = '#2196F3';
                map.getContainer().style.cursor = '';
                map.off('click', onMapClickGetCoords);
            }
        }

        function onMapClickGetCoords(e) {
            const lat = e.latlng.lat.toFixed(6);
            const lng = e.latlng.lng.toFixed(6);
            
            document.getElementById('site-lat').value = lat;
            document.getElementById('site-lng').value = lng;
            
            toggleGetCoordsMode();
        }

        function resetView() {
            map.setView([36.7783, -119.4179], 6);
        }

        function exportData() {
            window.open('/api/export-combined', '_blank');
        }

        // Limpiar puntos de usuario (funci√≥n placeholder)
        async function clearUserPoints() {
            if (confirm('¬øEst√°s seguro de que quieres eliminar todos tus puntos?')) {
                alert('Funcionalidad de limpieza pendiente de implementar en el servidor');
            }
        }

        // Resetear base de datos
        async function resetDatabase() {
            if (confirm('‚ö†Ô∏è ¬øEst√°s seguro de que quieres resetear la base de datos completa? Se perder√°n todos los pol√≠gonos ML y puntos de usuario.')) {
                try {
                    const response = await fetch('/api/reset-database', {
                        method: 'POST'
                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        // Recargar todo
                        await loadAllData();
                        alert('‚úÖ ' + result.message);
                    } else {
                        alert('‚ùå ' + result.message);
                    }
                } catch (error) {
                    console.error('Error reseteando base de datos:', error);
                    alert('‚ùå Error reseteando base de datos.');
                }
            }
        }

        function updateCounts() {
            document.getElementById('user-points-count').textContent = userPoints.length;
            document.getElementById('ml-vertices-count').textContent = mlVertices.length;
            
            // Contar pol√≠gonos ML
            const mlCount = mlLayer ? Object.keys(mlLayer._layers).length : 0;
            document.getElementById('ml-polygons-count').textContent = mlCount;
            
            // Contar total de pol√≠gonos
            const originalCount = originalLayer ? Object.keys(originalLayer._layers).length : 0;
            document.getElementById('total-polygons-count').textContent = originalCount + mlCount;
            
            // Actualizar estado de generaci√≥n autom√°tica
            const statusElement = document.getElementById('auto-generation-status');
            if (mlCount > 0) {
                statusElement.textContent = `‚úÖ ${mlCount} pol√≠gonos ML generados autom√°ticamente`;
                statusElement.className = 'status-indicator status-success';
            } else {
                statusElement.textContent = '‚ÑπÔ∏è No hay pol√≠gonos ML generados autom√°ticamente';
                statusElement.className = 'status-indicator status-info';
            }
        }

        function showTab(tabName) {
            // Ocultar todos los tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Mostrar tab seleccionado
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function getColorByType(type) {
            switch(type) {
                case 'Wild': return '#1b5e20';
                case 'Plantation': return '#ff6f00';
                default: return '#3388ff';
            }
        }

        // Inicializar cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
        });
    </script>
</body>
</html>